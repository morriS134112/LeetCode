int cmp (const void* a,const void* b){
    int a1 = *(const int*)a;
    int a2 = *(const int*)b;

    if (a1 < a2) return -1;
    if (a1 > a2) return 1;
    return 0;
}
bool containsDuplicate(int* nums, int numsSize) {
    qsort(nums,numsSize,sizeof(int),cmp);

    for(int i = 0; i <numsSize-1 ;i++){
        if(nums[i]==nums[i+1]) return true;
    }
    return false;
}


/**
1. qsort 是什麼？(通用排序大師)
qsort 是 C 語言標準函式庫 (<stdlib.h>) 裡的一個函式，全名是 Quick Sort (快速排序)。

它的厲害之處在於**「它什麼都能排」**。它可以排整數陣列、浮點數陣列，甚至是結構 (struct) 陣列。

為了做到「什麼都能排」，它不能預設知道你在排什麼（它只看得到記憶體位址），所以它需要你給它 4 個資訊：


qsort(nums, numsSize, sizeof(int), cmp);
nums (Base): 陣列從哪裡開始？(其實位址)
numsSize (Count): 總共有幾個東西要排？
sizeof(int) (Size): 每一個東西佔幾格記憶體？(因為 qsort 瞎了，不知道你是 int 還是 double，你要告訴它每次跳幾 byte)。
cmp (Compare Function): 這是最關鍵的。qsort 不知道怎麼比較大小，它需要你提供一個「裁判函式」。

2. cmp 函式解析 (裁判規則)
這就是那個「裁判」。qsort 在運作時，會不斷地抓兩個東西出來，丟給 cmp 問：「這兩個誰大？」

int cmp(const void *a, const void *b)
為什麼參數是 void *？
因為 qsort 是通用的，它丟進來的參數不能寫死成 int*。
void * 就像是 「密封的箱子」。qsort 遞給裁判兩個箱子 a 和 b，它自己不知道裡面裝什麼。

函式內部在做什麼？
開箱 (轉型與取值)：

int arg1 = *(const int*)a; 
(const int*)a: 告訴編譯器：「我知道這個箱子 a 裡面裝的是 int 指標，請把它當成 int 指標來看」。
*: 這個星號是 取出數值。把箱子裡的整數拿出來，存到 arg1。
判決 (比較)：
cmp 必須回傳三種整數之一告訴 qsort 結果：

負數 (< 0)：代表 a 比 b 小 (a 在前)。
正數 (> 0)：代表 a 比 b 大 (b 在前)。
零 (0)：代表 a 等於 b。
為什麼不直接寫 return arg1 - arg2？

邏輯上：如果 arg1 是 5，arg2 是 3，5 - 3 = 2 (正數)，代表前者大，看似正確。

但是如果有整數溢位 (Overflow) 就會出錯：

假設 arg1 是一個很大的負數 (例如 -20億) (INT_MIN)。
假設 arg2 是一個很大的正數 (例如 10億)。
arg1 - arg2 應該是負的 (前面比較小)。
但是 -20億 - 10億 = -30億。
−30億 超出了 int 的範圍 (約正負21億)，會發生溢位，數字會「繞一圈」變成正數！
結果：qsort 以為 arg1 比 arg2 大，把負數排到了正數後面，排序錯誤。
所以最安全的寫法是使用 if 來判斷：

總結比喻
qsort 是一個蒙著眼睛的圖書館管理員。他負責把書架上的書排好，但他看不懂書名，甚至不知道書有多厚。
你告訴他：「這書架有 100 本書 (numsSize)，每本書厚 4 公分 (sizeof(int))」。
cmp 是坐在旁邊的明眼人 (裁判)。
管理員隨手抓兩本書給裁判：「欸，這兩本誰該放前面？」
裁判 (cmp) 把書打開看數字，然後說：「第一本比較小 (-1)」。
管理員就根據這個指令去交換書的位置。
**/
